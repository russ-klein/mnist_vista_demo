
/**************************************************************/
/*                                                            */
/*               Copyright (c) Siemens 2021                   */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF SIEMENS       */
/*             CORPORATION OR ITS LICENSORS AND IS            */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The riscv_pv will be derived from this class.
//*
//* Model Builder version: 5.1.0
//* Generated on: Mar. 08, 2022 05:50:36 PM, (user: russk)
//*>


#include "riscv_model.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 5100 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 5.1.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;



riscv_pv_base::riscv_pv_base(sc_module_name& module_name) :
  riscv_pv_base_mb_compatibility(module_name),
  riscv_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(master),
  VISTA_MB_PV_INIT_MEMBER(n_periph_reset),
  VISTA_MB_PV_INIT_MEMBER(n_reset_0),
  VISTA_MB_PV_INIT_MEMBER(irq_0) {
  
  


  // master - not a vector port
  // n_periph_reset - not a vector port
  // n_reset_0 - not a vector port
  // irq_0 - not a vector port
  unsigned u = 0;



  payload_on_stack = 0;
  payload_for_token = 0;
  reset_registers();
  
  // reset value for output signals

  // reset value for input signals

  // n_periph_reset reset value not defined
  n_periph_reset.register_cb(this, &self::cb_signal_n_periph_reset);
  // n_reset_0 reset value not defined
  n_reset_0.register_cb(this, &self::cb_signal_n_reset_0);
  // irq_0 reset value not defined
  irq_0.register_cb(this, &self::cb_signal_irq_0);
  // master bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(master);
  // master bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(master);

}


riscv_pv_base::~riscv_pv_base() {
  
}



void riscv_pv_base::reset_registers() {
  // reset all registers
  unsigned u = 0;


}


void riscv_pv_base::reset_model() {
  
  reset_registers();
  // reset value for output signals

  // reset value for input signals

  // n_periph_reset reset value not defined
  // n_reset_0 reset value not defined
  // irq_0 reset value not defined


}

riscv_pv_base_parameters::riscv_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(10, sc_core::SC_NS), "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, signal_clock, clock, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, axi_clock, clock, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, port_enable, true, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING", "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master_outstanding, 1, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master_read_data_queue_size, 0, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master_write_data_queue_size, 0, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_periph_reset_pipeline_length, 2, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_reset_0_pipeline_length, 2, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, irq_0_pipeline_length, 2, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dcache_size, 32768, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, icache_size, 32768, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, l2_cache_size, 131072, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, control_page_address, 0, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, elf_image_file, "sw/dma_test.x", "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, gdbstub_port, 0, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, instruction_latency, clock, "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, instruction_energy, mb::utl::energy(5, mb::utl::NJ), "riscv"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lt_synch_quantum, sc_core::sc_time(50, sc_core::SC_US), "riscv")
{
  if(verbose_parameters) print_parameters();
}

void riscv_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent_object()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\tsignal_clock = " << signal_clock << "\n";
  std::cout << "\taxi_clock = " << axi_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tport_enable = " << port_enable << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tmaster_outstanding = " << master_outstanding << "\n";
  std::cout << "\tmaster_read_data_queue_size = " << master_read_data_queue_size << "\n";
  std::cout << "\tmaster_write_data_queue_size = " << master_write_data_queue_size << "\n";
  std::cout << "\tn_periph_reset_pipeline_length = " << n_periph_reset_pipeline_length << "\n";
  std::cout << "\tn_reset_0_pipeline_length = " << n_reset_0_pipeline_length << "\n";
  std::cout << "\tirq_0_pipeline_length = " << irq_0_pipeline_length << "\n";
  std::cout << "\tdcache_size = " << dcache_size << "\n";
  std::cout << "\ticache_size = " << icache_size << "\n";
  std::cout << "\tl2_cache_size = " << l2_cache_size << "\n";
  std::cout << "\tcontrol_page_address = " << control_page_address << "\n";
  std::cout << "\telf_image_file = " << elf_image_file << "\n";
  std::cout << "\tgdbstub_port = " << gdbstub_port << "\n";
  std::cout << "\tinstruction_latency = " << instruction_latency << "\n";
  std::cout << "\tinstruction_energy = " << instruction_energy << "\n";
  std::cout << "\tlt_synch_quantum = " << lt_synch_quantum << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}





/**************************************************************/
/*                                                            */
/*               Copyright (c) Siemens 2021                   */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF SIEMENS       */
/*             CORPORATION OR ITS LICENSORS AND IS            */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The riscv_t will be derived from this class.
//*
//* Model Builder version: 5.1.0
//* Generated on: Mar. 08, 2022 05:50:36 PM, (user: russk)
//*>




#include "riscv_model.h"
#include <math.h>
#include <stdlib.h>

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;




void riscv_t_base::schedule_axi_READ
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long ARADDR, long* RDATA, long ARSIZE, long block_size, long ARBURST, long ARLEN, long ARLOCK) {
  sc_dt::uint64 local_address = 0;
  local_address = ARADDR,
  scheduleGenericTransaction(port_index,
                             0,
                             local_address,
                             (unsigned char*)RDATA,
                             transactionSize,
                             block_size,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}



void riscv_t_base::schedule_axi_WRITE
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long AWADDR, long* WDATA, long AWSIZE, long block_size, long AWBURST, long AWLEN, long AWLOCK) {
  sc_dt::uint64 local_address = 0;
  local_address = AWADDR,
  scheduleGenericTransaction(port_index,
                             1,
                             local_address,
                             (unsigned char*)WDATA,
                             transactionSize,
                             block_size,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}




void riscv_t_base::start_transaction_axi_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  
  this->accept_axi_READ
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5], 
     parameters[6], 
     parameters[7]);
}


void riscv_t_base::end_transaction_axi_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  
  this->end_axi_READ
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5],
     parameters[6],
     parameters[7]);
}

void riscv_t_base::start_transaction_axi_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  
  this->accept_axi_WRITE
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5], 
     parameters[6], 
     parameters[7]);
}


void riscv_t_base::end_transaction_axi_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  
  this->end_axi_WRITE
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5],
     parameters[6],
     parameters[7]);
}

void riscv_t_base::start_transaction_signal_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();
  
  
  this->accept_signal_WRITE
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2]);
}


void riscv_t_base::end_transaction_signal_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();                                                                         
  
  this->end_signal_WRITE
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2]);
}

 riscv_t_base::TransactionCallbackFunctionPointer riscv_t_base::getTransactionCallback(unsigned callbackIndex) {
  static TransactionCallbackFunctionPointer funcArray[] = {
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::start_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::start_transaction_axi_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::end_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::end_transaction_axi_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&riscv_t_base::end_transaction_signal_WRITE),
    0
  };
  if(callbackIndex >= sizeof(funcArray) / sizeof(*funcArray) - 1)
    return 0;
  return funcArray[callbackIndex];
}


config::real80 riscv_t_base::get_state_power() {
  config::real80 power_value = 0;

  

  return power_value;
}


riscv_t_base::riscv_t_base(sc_module_name& module_name, long simulation) :
  papoulis::SystemCBaseModel(module_name),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(10, sc_core::SC_NS), "riscv"),
  SD_INITIALIZE_PARAMETER(signal_clock, clock, "riscv"),
  SD_INITIALIZE_PARAMETER(axi_clock, clock, "riscv"),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1, "riscv"),
  SD_INITIALIZE_PARAMETER(port_enable, true, "riscv"),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true, "riscv"),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true, "riscv"),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING", "riscv"),
  SD_INITIALIZE_PARAMETER(master_outstanding, 1, "riscv"),
  SD_INITIALIZE_PARAMETER(master_read_data_queue_size, 0, "riscv"),
  SD_INITIALIZE_PARAMETER(master_write_data_queue_size, 0, "riscv"),
  SD_INITIALIZE_PARAMETER(n_periph_reset_pipeline_length, 2, "riscv"),
  SD_INITIALIZE_PARAMETER(n_reset_0_pipeline_length, 2, "riscv"),
  SD_INITIALIZE_PARAMETER(irq_0_pipeline_length, 2, "riscv"),
  SD_INITIALIZE_PARAMETER(dcache_size, 32768, "riscv"),
  SD_INITIALIZE_PARAMETER(icache_size, 32768, "riscv"),
  SD_INITIALIZE_PARAMETER(l2_cache_size, 131072, "riscv"),
  SD_INITIALIZE_PARAMETER(control_page_address, 0, "riscv"),
  SD_INITIALIZE_PARAMETER(elf_image_file, "sw/dma_test.x", "riscv"),
  SD_INITIALIZE_PARAMETER(gdbstub_port, 0, "riscv"),
  SD_INITIALIZE_PARAMETER(instruction_latency, clock, "riscv"),
  SD_INITIALIZE_PARAMETER(instruction_energy, mb::utl::energy(5, mb::utl::NJ), "riscv"),
  SD_INITIALIZE_PARAMETER(lt_synch_quantum, sc_core::sc_time(50, sc_core::SC_US), "riscv"),
  m_simulation(simulation)
{
  bool separate_read_channel = false;  
  bool separate_write_channel = false;
  char* buffer = 0;
  unsigned port_index = 0;
  
  fix_clock_parameter(axi_clock, "axi_clock");
    separate_read_channel = false;
    separate_write_channel = false;
    buffer = new char[16];
    sprintf(buffer, "master");
    port_index = master;
    port_descriptions[port_index].port_name = buffer;
    separate_read_channel = true;
    port_descriptions[port_index].port_kind = PortDescription::READ_CHANNEL_PORT;
    separate_write_channel = true;
    port_descriptions[port_index].port_kind = PortDescription::WRITE_CHANNEL_PORT;
    if (separate_write_channel && separate_read_channel)
      port_descriptions[port_index].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
    port_descriptions[port_index].is_read_write_address_channel = 0;
    
    port_descriptions[port_index].is_master_port = 1;
    port_descriptions[port_index].is_signal_port = 0;
    port_descriptions[port_index].port_width = ((32 + 7) >> 3);
    port_descriptions[port_index].port_cast  = 0;
    port_descriptions[port_index].port_width_in_bits = 32;
    port_descriptions[port_index].protocol_name = "axi";
    port_descriptions[port_index].ipxactBusDef.vendor = "amba.com";
    port_descriptions[port_index].ipxactBusDef.library = "AMBA3";
    port_descriptions[port_index].ipxactBusDef.name = "AXI";
    port_descriptions[port_index].ipxactBusDef.version = "r1p0_5"; 
    port_descriptions[port_index].ipxactAbstrDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactAbstrDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactAbstrDef.name = "AXI_tlm20";
    port_descriptions[port_index].ipxactAbstrDef.version = "1.0";
    port_descriptions[port_index].port_must_bind = 1;
    port_descriptions[port_index].params_count = 8 + 10;
    if (master_outstanding == 0) {
      master_outstanding = 1;
      printf("WARNING: in \"%s\" the \"master_outstanding\" parameter is 0, a default value of 1 is used\n", name());
    }
    port_descriptions[port_index].pending = master_outstanding;
    port_descriptions[port_index].read_data_queue_size = master_read_data_queue_size;
    port_descriptions[port_index].write_data_queue_size = master_write_data_queue_size;
    port_descriptions[port_index].clock = axi_clock;
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  
  
  fix_clock_parameter(signal_clock, "signal_clock");
    separate_read_channel = false;
    separate_write_channel = false;
    buffer = new char[24];
    sprintf(buffer, "n_periph_reset");
    port_index = n_periph_reset;
    port_descriptions[port_index].port_name = buffer;
    separate_write_channel = true;
    port_descriptions[port_index].port_kind = PortDescription::WRITE_CHANNEL_PORT;
    if (separate_write_channel && separate_read_channel)
      port_descriptions[port_index].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
    port_descriptions[port_index].is_read_write_address_channel = 0;
    
    port_descriptions[port_index].is_master_port = 0;
    port_descriptions[port_index].is_signal_port = 1;
    port_descriptions[port_index].port_width = ((1 + 7) >> 3);
    port_descriptions[port_index].port_cast  = 0;
    port_descriptions[port_index].port_width_in_bits = 1;
    port_descriptions[port_index].protocol_name = "signal";
    port_descriptions[port_index].ipxactBusDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactBusDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactBusDef.name = "signal";
    port_descriptions[port_index].ipxactBusDef.version = "1.0"; 
    port_descriptions[port_index].ipxactAbstrDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactAbstrDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactAbstrDef.name = "signal_tlm20";
    port_descriptions[port_index].ipxactAbstrDef.version = "1.0";
    port_descriptions[port_index].port_must_bind = 0;
    port_descriptions[port_index].params_count = 3 + 10;
    port_descriptions[port_index].clock = signal_clock;
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  
  
  fix_clock_parameter(signal_clock, "signal_clock");
    separate_read_channel = false;
    separate_write_channel = false;
    buffer = new char[19];
    sprintf(buffer, "n_reset_0");
    port_index = n_reset_0;
    port_descriptions[port_index].port_name = buffer;
    separate_write_channel = true;
    port_descriptions[port_index].port_kind = PortDescription::WRITE_CHANNEL_PORT;
    if (separate_write_channel && separate_read_channel)
      port_descriptions[port_index].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
    port_descriptions[port_index].is_read_write_address_channel = 0;
    
    port_descriptions[port_index].is_master_port = 0;
    port_descriptions[port_index].is_signal_port = 1;
    port_descriptions[port_index].port_width = ((1 + 7) >> 3);
    port_descriptions[port_index].port_cast  = 0;
    port_descriptions[port_index].port_width_in_bits = 1;
    port_descriptions[port_index].protocol_name = "signal";
    port_descriptions[port_index].ipxactBusDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactBusDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactBusDef.name = "signal";
    port_descriptions[port_index].ipxactBusDef.version = "1.0"; 
    port_descriptions[port_index].ipxactAbstrDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactAbstrDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactAbstrDef.name = "signal_tlm20";
    port_descriptions[port_index].ipxactAbstrDef.version = "1.0";
    port_descriptions[port_index].port_must_bind = 0;
    port_descriptions[port_index].params_count = 3 + 10;
    port_descriptions[port_index].clock = signal_clock;
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  
  
  fix_clock_parameter(signal_clock, "signal_clock");
    separate_read_channel = false;
    separate_write_channel = false;
    buffer = new char[15];
    sprintf(buffer, "irq_0");
    port_index = irq_0;
    port_descriptions[port_index].port_name = buffer;
    separate_write_channel = true;
    port_descriptions[port_index].port_kind = PortDescription::WRITE_CHANNEL_PORT;
    if (separate_write_channel && separate_read_channel)
      port_descriptions[port_index].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
    port_descriptions[port_index].is_read_write_address_channel = 0;
    
    port_descriptions[port_index].is_master_port = 0;
    port_descriptions[port_index].is_signal_port = 1;
    port_descriptions[port_index].port_width = ((1 + 7) >> 3);
    port_descriptions[port_index].port_cast  = 0;
    port_descriptions[port_index].port_width_in_bits = 1;
    port_descriptions[port_index].protocol_name = "signal";
    port_descriptions[port_index].ipxactBusDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactBusDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactBusDef.name = "signal";
    port_descriptions[port_index].ipxactBusDef.version = "1.0"; 
    port_descriptions[port_index].ipxactAbstrDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactAbstrDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactAbstrDef.name = "signal_tlm20";
    port_descriptions[port_index].ipxactAbstrDef.version = "1.0";
    port_descriptions[port_index].port_must_bind = 0;
    port_descriptions[port_index].params_count = 3 + 10;
    port_descriptions[port_index].clock = signal_clock;
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
    port_descriptions[port_index].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  

  port_descriptions[master].default_read_transaction_name = "READ";
  
  port_descriptions[master].default_write_transaction_name = "WRITE";
  
  port_descriptions[n_periph_reset].default_write_transaction_name = "WRITE";
  
  port_descriptions[n_reset_0].default_write_transaction_name = "WRITE";
  
  port_descriptions[irq_0].default_write_transaction_name = "WRITE";
  

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);

  bool isCpu = false;
  isCpu = true;
  esl::tlm_sim::UserRunningModel* userRunningModel = Papoulis_CreateUserRunningModel(name(),
                                                                                     0,
                                                                                     this,
                                                                                     simulation,
                                                                                     false,
                                                                                     isCpu);
  setUserRunningModel(userRunningModel, isCpu);
  set_nominal_voltage(nominal_voltage);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("signal_clock", "sc_core::sc_time", sdGetParameterAsConstString("signal_clock"));
  registerParameter("axi_clock", "sc_core::sc_time", sdGetParameterAsConstString("axi_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("port_enable", "bool", sdGetParameterAsConstString("port_enable"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("master_outstanding", "unsigned int", sdGetParameterAsConstString("master_outstanding"));
  registerParameter("master_read_data_queue_size", "unsigned int", sdGetParameterAsConstString("master_read_data_queue_size"));
  registerParameter("master_write_data_queue_size", "unsigned int", sdGetParameterAsConstString("master_write_data_queue_size"));
  registerParameter("n_periph_reset_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_periph_reset_pipeline_length"));
  registerParameter("n_reset_0_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_reset_0_pipeline_length"));
  registerParameter("irq_0_pipeline_length", "unsigned int", sdGetParameterAsConstString("irq_0_pipeline_length"));
  registerParameter("dcache_size", "unsigned int", sdGetParameterAsConstString("dcache_size"));
  registerParameter("icache_size", "unsigned int", sdGetParameterAsConstString("icache_size"));
  registerParameter("l2_cache_size", "unsigned int", sdGetParameterAsConstString("l2_cache_size"));
  registerParameter("control_page_address", "unsigned long long", sdGetParameterAsConstString("control_page_address"));
  registerParameter("elf_image_file", "const char*", sdGetParameterAsConstString("elf_image_file"));
  registerParameter("gdbstub_port", "unsigned int", sdGetParameterAsConstString("gdbstub_port"));
  registerParameter("instruction_latency", "sc_core::sc_time", sdGetParameterAsConstString("instruction_latency"));
  registerParameter("instruction_energy", "mb::utl::energy", sdGetParameterAsConstString("instruction_energy"));
  registerParameter("lt_synch_quantum", "sc_core::sc_time", sdGetParameterAsConstString("lt_synch_quantum"));
  set_sync_all(0); 
  
  
  
  
  

  
  

  


  

  constant_global_power_policy* p = new constant_global_power_policy(userRunningModel);
  
  
  
  set_global_power_policy(p);
}


void riscv_t_base::update_sync_all() {
  set_sync_all(0);
  
}


void riscv_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;


}


void riscv_t_base::update_sequential_parameters(esl::sc_sim::sequential_policy* handle) {
  if (m_sequential_vector.size() == 0)
    return;

}


void riscv_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

}


void riscv_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}


void riscv_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}


void riscv_t_base::update_state_power_parameters(esl::sc_sim::state_power_policy* handle) {
  if (m_state_power_vector.size() == 0)
    return;

}


void riscv_t_base::update_global_power_parameters(esl::sc_sim::constant_global_power_policy* handle) {
  
  
  return;  
}


bool riscv_t_base::triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans) {
  mb::utl::Segment<uint64_t> transactionRange(trans.get_address(), trans.get_address() + trans.get_data_length());

  return false;
}


bool riscv_t_base::portHasRegisters(unsigned portIndex) {
  switch (portIndex) {

  }
  return false;
}




/**************************************************************/
/*                                                            */
/*               Copyright (c) Siemens 2021                   */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF SIEMENS       */
/*             CORPORATION OR ITS LICENSORS AND IS            */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for riscv.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 5.1.0
//* Generated on: Mar. 08, 2022 05:50:36 PM, (user: russk)
//*>

#include "riscv_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;



#include "riscv_pv.h"




// Constructor

riscv_pvt::riscv_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 1),
    riscv_pvt_param_defaults(this->name()),
    master("master"),
    n_periph_reset("n_periph_reset"),
    n_reset_0("n_reset_0"),
    irq_0("irq_0"),
    master_entry("unvisible_master_entry"),
  n_periph_reset_entry("unvisible_n_periph_reset_entry"),
  n_reset_0_entry("unvisible_n_reset_0_entry"),
  irq_0_entry("unvisible_irq_0_entry")
  

  ,m_master_nb_connector(*this),
    m_n_periph_reset_nb_connector(*this),
    m_n_reset_0_nb_connector(*this),
    m_irq_0_nb_connector(*this)
  
    

{
  // master - not a vector port

  // n_periph_reset - not a vector signal
  // n_reset_0 - not a vector signal
  // irq_0 - not a vector signal


  m_riscv_t = riscv_t_base::create_t("T", 1);
  m_riscv_pv = new riscv_pv("PV");
  bind();
}  


riscv_pvt::riscv_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time signal_clock_init, sc_core::sc_time axi_clock_init, double nominal_voltage_init, bool port_enable_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, unsigned int master_outstanding_init, unsigned int master_read_data_queue_size_init, unsigned int master_write_data_queue_size_init, unsigned int n_periph_reset_pipeline_length_init, unsigned int n_reset_0_pipeline_length_init, unsigned int irq_0_pipeline_length_init, unsigned int dcache_size_init, unsigned int icache_size_init, unsigned int l2_cache_size_init, unsigned long long control_page_address_init, const char* elf_image_file_init, unsigned int gdbstub_port_init, sc_core::sc_time instruction_latency_init, mb::utl::energy instruction_energy_init, sc_core::sc_time lt_synch_quantum_init)
  : esl::sc_sim::PVTBaseModel(module_name, 1),
  riscv_pvt_param_defaults(this->name(), clock_init, signal_clock_init, axi_clock_init, nominal_voltage_init, port_enable_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, master_outstanding_init, master_read_data_queue_size_init, master_write_data_queue_size_init, n_periph_reset_pipeline_length_init, n_reset_0_pipeline_length_init, irq_0_pipeline_length_init, dcache_size_init, icache_size_init, l2_cache_size_init, control_page_address_init, elf_image_file_init, gdbstub_port_init, instruction_latency_init, instruction_energy_init, lt_synch_quantum_init),
    master("master"),
    n_periph_reset("n_periph_reset"),
    n_reset_0("n_reset_0"),
    irq_0("irq_0"),
    master_entry("unvisible_master_entry"),
    n_periph_reset_entry("unvisible_n_periph_reset_entry"),
    n_reset_0_entry("unvisible_n_reset_0_entry"),
    irq_0_entry("unvisible_irq_0_entry")
    

    ,m_master_nb_connector(*this),
    m_n_periph_reset_nb_connector(*this),
    m_n_reset_0_nb_connector(*this),
    m_irq_0_nb_connector(*this)
    
    
{

  // master - not a vector port
  // n_periph_reset - not a vector signal
  // n_reset_0 - not a vector signal
  // irq_0 - not a vector signal
  


  m_riscv_t = riscv_t_base::create_t("T", 1);
  m_riscv_pv = new riscv_pv("PV");
  bind();
} 


riscv_pvt::riscv_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 1),
  riscv_pvt_param_defaults(this->name(), change_parameters),
    master("master"),
    n_periph_reset("n_periph_reset"),
    n_reset_0("n_reset_0"),
    irq_0("irq_0"),
    master_entry("unvisible_master_entry"),
    n_periph_reset_entry("unvisible_n_periph_reset_entry"),
    n_reset_0_entry("unvisible_n_reset_0_entry"),
    irq_0_entry("unvisible_irq_0_entry")
    

    ,m_master_nb_connector(*this),
    m_n_periph_reset_nb_connector(*this),
    m_n_reset_0_nb_connector(*this),
    m_irq_0_nb_connector(*this)
    
{

  // master - not a vector port
  


  m_riscv_t = riscv_t_base::create_t("T", 1);
  m_riscv_pv = new riscv_pv("PV");
  bind();
} 


riscv_pvt::~riscv_pvt() {
  remove_pending_scenes();
  
  delete m_riscv_t;
  
  delete m_riscv_pv;
}





void riscv_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->master.bind(master_entry);  
  n_periph_reset_entry(getPV()->n_periph_reset);
  n_reset_0_entry(getPV()->n_reset_0);
  irq_0_entry(getPV()->irq_0);

  /* set callbacks on external and entry ports */ 

  n_periph_reset.b_transport_cb.set(this, &self_type::b_transport_inside_n_periph_reset);

  n_reset_0.b_transport_cb.set(this, &self_type::b_transport_inside_n_reset_0);

  irq_0.b_transport_cb.set(this, &self_type::b_transport_inside_irq_0);

  master_entry.b_transport_cb.set(this, &self_type::b_transport_outside_master);
  master_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_master);
  master_entry.get_direct_mem_ptr_cb.set(&master, &master_type::get_direct_mem_ptr);
  
  
  /* connect t non blocking callbacks */

  master.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_master);
  getT()->set_port_cb(0, &m_master_nb_connector);
  
  n_periph_reset.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_periph_reset);
  getT()->set_port_cb(1, &m_n_periph_reset_nb_connector);
  
  n_reset_0.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_reset_0);
  getT()->set_port_cb(2, &m_n_reset_0_nb_connector);
  
  irq_0.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_irq_0);
  getT()->set_port_cb(3, &m_irq_0_nb_connector);
  
  master.invalidate_direct_mem_ptr_cb.set(&master_entry, &master_entry_type::invalidate_direct_mem_ptr);
  
  /* check mb_event policies */
  m_riscv_t->check_mb_events();
  
}



void riscv_pvt::b_transport_inside_n_periph_reset(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_riscv_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken()); 
  }
 
  n_periph_reset_entry.write(*(bool*)p.get_data_ptr());

}

void riscv_pvt::b_transport_inside_n_reset_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_riscv_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken()); 
  }
 
  n_reset_0_entry.write(*(bool*)p.get_data_ptr());

}

void riscv_pvt::b_transport_inside_irq_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_riscv_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken()); 
  }
 
  irq_0_entry.write(*(bool*)p.get_data_ptr());

}


void riscv_pvt::b_transport_outside_master(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  master.b_transport(p, t); 
} 


unsigned int riscv_pvt::transport_dbg_outside_master(tlm::tlm_generic_payload& p)
{
  

  return master.transport_dbg(p); 
}



