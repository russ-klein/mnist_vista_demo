
/**************************************************************/
/*                                                            */
/*               Copyright (c) Siemens 2021                   */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF SIEMENS       */
/*             CORPORATION OR ITS LICENSORS AND IS            */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for conv_2d.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 5.1.0
//* Generated on: May. 24, 2022 12:54:06 PM, (user: russk)
//*>



#include "conv_2d_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor

#define MEMORY_BASE (0x40800000)

conv_2d_pv::conv_2d_pv(sc_module_name module_name)
  : conv_2d_pv_base(module_name) {
}   

/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a 
// write event on one of the registers as defined in the Model Builder form.
// These functions are called before the write callbacks on the port.
///////////////////////////////////////////////////////////////////////////////// 

// Write callback for go register.
// The newValue has been already assigned to the go register.

void conv_2d_pv::cb_write_go(unsigned int newValue) {

  unsigned int data;
  ac_fixed<32, 16, true> acf;
  ac_int<32, true> cpp_is_stupid;

  for (int i=0;i<20;i++) {
    master_read(MEMORY_BASE + i * 4, data);
    cpp_is_stupid = data;
    acf.set_slc(0, cpp_is_stupid);
    printf("data %d value: %08x %f \n", i, data, acf.to_double());
  }

  printf("I'm going to stop \n");
  //sc_stop();

  if (go_ready) {
    go_ready = 0;
    done = 0;

printf("You will never see this... \n");
    conv_2d_vista();
printf("Did you see that?\n");

    go_ready = 1;
    done = 1;
    done_valid = 1;
  }
printf("hw side:: conv_2d completed and exiting \n");
}
    

// Read callback for slave port.
// Returns true when successful.

bool conv_2d_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  printf("slave callback read \n");
  return true;
}

// Write callback for slave port.
// Returns true when successful.

bool conv_2d_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  printf("slave callback write \n");
  return true;
} 





unsigned conv_2d_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned conv_2d_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool conv_2d_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

void conv_2d_pv::cb_transport_dbg_go(tlm::tlm_generic_payload& trans) {
  return;
}


conv_2d_pv::hw_cat_type conv_2d_pv::get_cat_value(int memory, unsigned int address)
{
  unsigned int buffer[10];
  hw_cat_type r;

  master_read(MEMORY_BASE + address * 4, buffer, 1);
  r.set_slc(0, (ac_int<32,false>) buffer[0]);
// printf("read operation conv2d accelerator: address: %08x data: %08x as float: %f \n", 0x40000000 + address * 4, buffer[0], r.to_double());
  return r;
}

void conv_2d_pv::set_cat_value(int memory, unsigned int address, hw_cat_type data)
{
  unsigned int buffer[10];
  unsigned int d;

  buffer[0] = data.slc<32>(0);
  master_write(MEMORY_BASE + address * 4, buffer, 1);
}

void conv_2d_pv::print_image(int image_offset, int height, int width)
{
   int r, c;
   hw_cat_type hct;
   float f;
   int offset;

   printf(" \n");
   for (r=0; r<height; r++) {
      for (c=0; c<width; c++) {
         offset = r * width + c + image_offset;
         hct = get_cat_value(0, offset);
         f = hct.to_double();
         if ((-0.001<f) && (f<0.001)) printf("   -   "); else printf(" %5.2f ", f);
      }
      printf("\n");
   }
   printf("\n\n");
}

void conv_2d_pv::print_filter(int filter_offset, int height, int width)
{
   int r, c;
   hw_cat_type hct;
   float f;
   int offset;

   printf(" \n");
   for (r=0; r<height; r++) {
      for (c=0; c<width; c++) {
         offset = r * width + c + filter_offset;
         hct = get_cat_value(0, offset);
         f = hct.to_double();
         printf(" %5.2f ", f);
      }
      printf("\n");
   }
   printf("\n\n");
}

int conv_2d_pv::in_bounds(
              int r,
              int c,
              int height,
              int width)
{
    if (r < 0)        return 0;
    if (r >= height)  return 0;
    if (c < 0)        return 0;
    if (c >= width)   return 0;
    return 1;
}


int conv_2d_pv::offset(int row, int col, int image, int height, int width, int images)
{
    int start_of_array = image * height * width;
    int pixel_offset = (row * width) + col;

    return start_of_array + pixel_offset;
}


#define OFFSET(ROW, COL, IMAGE) offset(ROW, COL, IMAGE, height, width, num_input_images)

int conv_2d_pv::weight_offset(int row, int col, int input_image, int output_image, int height, int width, int num_input_images, int num_output_images)
{
    return output_image * height * width * num_input_images + input_image * height * width + row * width + col;
}


#define WEIGHT_OFFSET(ROW, COL, IN_IMAGE, OUT_IMAGE) weight_offset(ROW, COL, IN_IMAGE, OUT_IMAGE, filter_height, filter_width, num_input_images, num_output_images)



unsigned int conv_2d_pv::vista_read_bus(unsigned int address)
{
  unsigned int buffer[1];
  master_read(address, buffer, 1);
  return(buffer[0]);
}

void conv_2d_pv::vista_write_bus(unsigned int address, unsigned int data)
{
  unsigned int buffer[1];

  buffer[0] = data;
  master_write(address, buffer, 1);
}

// in order to minimize merging conflicts, we recommend to add your functions after this commen

void conv_2d_pv::conv_2d_vista()
{
    int  o, i, fr, fc, r, c, rr, cc, r1, c1;
    hw_cat_type sum;
    hw_cat_type max;
    hw_cat_type n;
    hw_cat_type image_value;
    hw_cat_type weight_value;
    hw_cat_type bias_value;
    int image_index;
    int weight_index;
    int output_index;
    int input_index;

    const int chatty = 0;
    const int stride = 2;

int imoff = image;
int woff = weights;
int ooff = output_image;
int h = height;
int w = width;

printf("image offset:  %d \n", imoff);
printf("output offset: %d \n", ooff);
printf("weight offset: %d \n", woff);
printf("height:        %d \n", h);
printf("width:         %d \n", w);


printf("convolution input image: =========>>\n");
print_image(image, height, width);
print_filter(weights, filter_height, filter_width);

    int memory = 0;
    printf("staring convolution \n");
    for (o=0; o<num_output_images; o++) {
int no = num_output_images;
printf("%d of %d output images \n", o, no);
        for (i=0; i<num_input_images; i++) {
int ni = num_input_images;
printf("%d of %d input images \n", i, ni);
            for (r=0; r<height; r++) {
                for (c=0; c<width; c++) {
                    sum = 0.0;
                    for (fr=0; fr<filter_height; fr++) {
                        for (fc=0; fc<filter_width; fc++) {

                            rr = r + fr - (filter_height -1)/2;
                            cc = c + fc - (filter_width -1)/2;

                            if (in_bounds(rr, cc, height, width)) {

                                image_index = OFFSET(rr, cc, i);
                                weight_index = WEIGHT_OFFSET(fr, fc, i, o);
                               
//printf("Calling get_cat_value() \n");
                                image_value = get_cat_value(memory, image + image_index);
                                weight_value = get_cat_value(memory, weights + weight_index);

                                if (chatty) printf("vista: HW image_index: %d weight_index: %d image_value[%d][%d]: %5.3f weight_value: %5.3f = %5.3f \n",
                                                   image_index, weight_index, r+fr, c+fc, image_value.to_double(),
                                                   weight_value.to_double(), image_value.to_double() * weight_value.to_double());

                                sum += image_value * weight_value;
                            }
                        }
                    }
                    output_index = OFFSET(r, c, o);
                    if (i==0) n = sum; else n = sum + get_cat_value(memory, output_image + output_index);
                    set_cat_value(memory, output_image + output_index, n);
                    if (chatty) printf("output[%d] = %5.3f \n", output_index, n.to_double());
                }
            }
        }
        if (bias) {
            for (r=0; r<height; r++) {
                for (c=0; c<width; c++) {
                    output_index = OFFSET(r, c, o);
                    image_value = get_cat_value(memory, output_image + output_index);
                    bias_value = get_cat_value(memory, biases + o);
                    set_cat_value(memory, output_image + output_index, image_value + bias_value);
                }
            }
        }
        if (relu) {
            for (r=0; r<height; r++) {
                for (c=0; c<width; c++) {
                    output_index = OFFSET(r, c, o);
                    n = get_cat_value(memory, output_image + output_index);
                    if (n<0) set_cat_value(memory, output_image + output_index, 0.0);
                }
            }
        }
        if (maxpool) {
            for (r=0; r<height/stride; r++) {
                for (c=0; c<width/stride; c++) {

                    input_index = offset(r*stride, c*stride, o, height, width, num_output_images);
                    output_index = offset(r, c, o, height/stride, width/stride, num_output_images);

                    max = get_cat_value(memory, output_image + input_index); // output_image[input_index];
                    for (r1=0; r1<stride; r1++) {
                        for (c1=0; c1<stride; c1++) {
                            input_index = offset(r*stride + r1, c*stride + c1, o, height, width, num_output_images);

                            n = get_cat_value(memory, output_image + input_index); // output_image[input_index];
                            if (n > max) {
                                max = n;
                            }
                        }
                    }
                    set_cat_value(memory, output_image + output_index, max); // output_image[output_index] = max;
                }
            }
        }
    }
printf("convolution done \n");
}
