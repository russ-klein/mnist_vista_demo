
/**************************************************************/
/*                                                            */
/*               Copyright (c) Siemens 2021                   */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF SIEMENS       */
/*             CORPORATION OR ITS LICENSORS AND IS            */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The axi_bus_pv will be derived from this class.
//*
//* Model Builder version: 5.1.0
//* Generated on: Mar. 09, 2022 11:24:25 AM, (user: russk)
//*>


#include "axi_bus_model.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 5100 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 5.1.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;



axi_bus_pv_base::axi_bus_pv_base(sc_module_name& module_name) :
  axi_bus_pv_base_mb_compatibility(module_name),
  axi_bus_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(dma_slave),
  VISTA_MB_PV_INIT_MEMBER(mem_slave),
  VISTA_MB_PV_INIT_MEMBER(code_and_data),
  VISTA_MB_PV_INIT_MEMBER(console),
  VISTA_MB_PV_INIT_MEMBER(cpu_master),
  VISTA_MB_PV_INIT_MEMBER(dma_master) {
  
  


  // dma_slave - not a vector port
  // mem_slave - not a vector port
  // code_and_data - not a vector port
  // console - not a vector port
  // cpu_master - not a vector port
  // dma_master - not a vector port
  unsigned u = 0;



  payload_on_stack = 0;
  payload_for_token = 0;
  reset_registers();
  
  // reset value for output signals

  // reset value for input signals

  // cpu_master bw binding 
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(cpu_master);
  // dma_master bw binding 
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(dma_master);
  // dma_slave bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(dma_slave);
  // mem_slave bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(mem_slave);
  // code_and_data bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(code_and_data);
  // console bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(console);
  // cpu_master bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(cpu_master);
  // dma_master bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(dma_master);
  // dma_slave bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(dma_slave);
  // mem_slave bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(mem_slave);
  // code_and_data bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(code_and_data);
  // console bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(console);

}


axi_bus_pv_base::~axi_bus_pv_base() {
  
}



void axi_bus_pv_base::reset_registers() {
  // reset all registers
  unsigned u = 0;


}


void axi_bus_pv_base::reset_model() {
  
  reset_registers();
  // reset value for output signals

  // reset value for input signals



}

axi_bus_pv_base_parameters::axi_bus_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(10, sc_core::SC_NS), "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, axi_clock, clock, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, port_enable, true, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING", "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, layers, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, slave_sets, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, write_broadcast, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dma_slave_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dma_slave_base_address, 0x70000000, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dma_slave_size, 0x10000, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dma_slave_subtract_base_address, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dma_slave_secure, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dma_slave_additional_ranges, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dma_slave_latency, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mem_slave_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mem_slave_base_address, 0x40000000, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mem_slave_size, 0x100000, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mem_slave_subtract_base_address, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mem_slave_secure, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mem_slave_additional_ranges, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mem_slave_latency, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, cpu_master_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, cpu_master_vmap, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dma_master_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dma_master_vmap, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, code_and_data_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, code_and_data_base_address, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, code_and_data_size, 0x10000000, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, code_and_data_subtract_base_address, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, code_and_data_secure, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, code_and_data_additional_ranges, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, code_and_data_latency, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, console_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, console_base_address, 0x60080000, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, console_size, 0x10000, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, console_subtract_base_address, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, console_secure, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, console_additional_ranges, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, console_latency, 0, "axi_bus")
{
  if(verbose_parameters) print_parameters();
}

void axi_bus_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent_object()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\taxi_clock = " << axi_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tport_enable = " << port_enable << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tlayers = " << layers << "\n";
  std::cout << "\tslave_sets = " << slave_sets << "\n";
  std::cout << "\twrite_broadcast = " << write_broadcast << "\n";
  std::cout << "\tdma_slave_priority = " << dma_slave_priority << "\n";
  std::cout << "\tdma_slave_base_address = " << dma_slave_base_address << "\n";
  std::cout << "\tdma_slave_size = " << dma_slave_size << "\n";
  std::cout << "\tdma_slave_subtract_base_address = " << dma_slave_subtract_base_address << "\n";
  std::cout << "\tdma_slave_secure = " << dma_slave_secure << "\n";
  std::cout << "\tdma_slave_additional_ranges = " << dma_slave_additional_ranges << "\n";
  std::cout << "\tdma_slave_latency = " << dma_slave_latency << "\n";
  std::cout << "\tmem_slave_priority = " << mem_slave_priority << "\n";
  std::cout << "\tmem_slave_base_address = " << mem_slave_base_address << "\n";
  std::cout << "\tmem_slave_size = " << mem_slave_size << "\n";
  std::cout << "\tmem_slave_subtract_base_address = " << mem_slave_subtract_base_address << "\n";
  std::cout << "\tmem_slave_secure = " << mem_slave_secure << "\n";
  std::cout << "\tmem_slave_additional_ranges = " << mem_slave_additional_ranges << "\n";
  std::cout << "\tmem_slave_latency = " << mem_slave_latency << "\n";
  std::cout << "\tcpu_master_priority = " << cpu_master_priority << "\n";
  std::cout << "\tcpu_master_vmap = " << cpu_master_vmap << "\n";
  std::cout << "\tdma_master_priority = " << dma_master_priority << "\n";
  std::cout << "\tdma_master_vmap = " << dma_master_vmap << "\n";
  std::cout << "\tcode_and_data_priority = " << code_and_data_priority << "\n";
  std::cout << "\tcode_and_data_base_address = " << code_and_data_base_address << "\n";
  std::cout << "\tcode_and_data_size = " << code_and_data_size << "\n";
  std::cout << "\tcode_and_data_subtract_base_address = " << code_and_data_subtract_base_address << "\n";
  std::cout << "\tcode_and_data_secure = " << code_and_data_secure << "\n";
  std::cout << "\tcode_and_data_additional_ranges = " << code_and_data_additional_ranges << "\n";
  std::cout << "\tcode_and_data_latency = " << code_and_data_latency << "\n";
  std::cout << "\tconsole_priority = " << console_priority << "\n";
  std::cout << "\tconsole_base_address = " << console_base_address << "\n";
  std::cout << "\tconsole_size = " << console_size << "\n";
  std::cout << "\tconsole_subtract_base_address = " << console_subtract_base_address << "\n";
  std::cout << "\tconsole_secure = " << console_secure << "\n";
  std::cout << "\tconsole_additional_ranges = " << console_additional_ranges << "\n";
  std::cout << "\tconsole_latency = " << console_latency << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}





/**************************************************************/
/*                                                            */
/*               Copyright (c) Siemens 2021                   */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF SIEMENS       */
/*             CORPORATION OR ITS LICENSORS AND IS            */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/


#include <iostream>





axi_bus_base1_pv::axi_bus_base1_pv(sc_module_name module_name) :
  axi_bus_pv_base(module_name) , m_fast_mode(false), p_port_dci_ext(NULL) {
  dbg_port.bind(m_dbg_port_fw_process);
  if(!mb::tlm20::is_fast_mode()) {
    m_dbg_port_fw_process.register_b_transport(this, &axi_bus_base1_pv::dbg_port_callback);
    m_dbg_port_fw_process.register_transport_dbg(this, &axi_bus_base1_pv::dbg_port_callback_dbg);
    m_dbg_port_fw_process.register_get_direct_mem_ptr(this, &axi_bus_base1_pv::dbg_port_get_direct_memory_ptr_callback);
  } else {
    m_fast_mode = true;
  }
  m_model = dynamic_cast<PapoulisBusBaseModel *>(getSystemCBaseModel());
  if (m_model) {
    decoder = m_model->get_decoder();
 
  } else {
    decoder = new esl::sc_sim::user_model::Decoder(2, 6, write_broadcast);
    decoder->registerSlavePort(0, this->dma_slave_base_address, this->dma_slave_size, this->dma_slave_subtract_base_address);     
    decoder->parseSlavePortAdditionalRanges(0,
                                            "dma_slave",
                                            this->dma_slave_additional_ranges,
                                            this->dma_slave_subtract_base_address);
    decoder->registerSlavePort(1, this->mem_slave_base_address, this->mem_slave_size, this->mem_slave_subtract_base_address);     
    decoder->parseSlavePortAdditionalRanges(1,
                                            "mem_slave",
                                            this->mem_slave_additional_ranges,
                                            this->mem_slave_subtract_base_address);
    decoder->registerSlavePort(4, this->code_and_data_base_address, this->code_and_data_size, this->code_and_data_subtract_base_address);     
    decoder->parseSlavePortAdditionalRanges(4,
                                            "code_and_data",
                                            this->code_and_data_additional_ranges,
                                            this->code_and_data_subtract_base_address);
    decoder->registerSlavePort(5, this->console_base_address, this->console_size, this->console_subtract_base_address);     
    decoder->parseSlavePortAdditionalRanges(5,
                                            "console",
                                            this->console_additional_ranges,
                                            this->console_subtract_base_address);
    decoder->parseVmapString(2, this->cpu_master_vmap, "cpu_master_vmap");
    decoder->parseVmapString(3, this->dma_master_vmap, "dma_master_vmap");
  }
  
  for(unsigned u = 0; u < 2; u++) {
    startIdxArray[u] = 0;
  }

  m_port_count = 6;
  // Add listener for Slave Priority Parameter
  for(unsigned u = 0; u < 2; u++) {
    std::string prio_param = get_port_name(u);
    prio_param = prio_param + "_priority";
    mb::sysc::add_parameter_listener(this->name(), prio_param.c_str(), this);
  }
  if(!m_fast_mode) {
    m_layers_count = m_model ? m_model->get_arbiter()->get_layers_count() : 0;
    m_is_multi_channel = 1;
    m_bus_scheduler = new esl::sc_sim::BusScheduler(m_port_count, m_layers_count, m_is_multi_channel);
    m_apply_policies = false;
    m_in_loop = false;
    const char* policy_modeling = "lt_policy_modeling";
    
    mb::sysc::add_parameter_listener(this->name(), policy_modeling, this);
    if (mb::sysc::sdParameterExists(policy_modeling)) {
      if (!strcasecmp(mb::sysc::sdGetParameterAsConstString(policy_modeling), "dynamic")) {
        m_apply_policies = true;
        mb::sysc::set_parameter<const char*>("lt_cpu_policy_modeling", "dynamic");
      }
    }
  }
}

axi_bus_base1_pv::~axi_bus_base1_pv()
{
  if(!m_fast_mode) 
    delete m_bus_scheduler;
}
void axi_bus_base1_pv::parameter_changed(const std::string& parameter,
                                               const std::string& old_value,
                                             const std::string& new_value) {
 if(parameter == "lt_policy_modeling")
 {
   if (!strcasecmp(new_value.c_str(), "dynamic")) {
     m_apply_policies = true;
   }
   else {
     m_apply_policies = false;
   }
   mb::sysc::set_parameter<const char*>("lt_cpu_policy_modeling", new_value.c_str());
 }
 else if(parameter.find("_priority", 0) != string::npos)
 {
    for(unsigned u = 0; u < 2; u++) {
      std::string slave_priority = get_port_name(u);
      slave_priority = slave_priority + "_priority";
      unsigned param_value = mb::sysc::get_parameter<unsigned>(slave_priority.c_str(), 0);
      if(slave_priority == parameter)
        decoder->setPriority(u, param_value);
    }
  }  
}



void axi_bus_base1_pv::cpu_master_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 2, false, t);
  
}

unsigned axi_bus_base1_pv::cpu_master_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 2, true, t);

}

bool axi_bus_base1_pv::cpu_master_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  if(m_fast_mode)
    return routePayload(trans, dmiData, 2);
  else {
    mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
      trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
    if (mb_unlikely(discovery_ext != 0)) {
      sc_dt::uint64 offset;
      sc_dt::uint64 base = discovery_ext->get_base_address(trans);
      if (this->dma_slave_subtract_base_address) {
        offset = this->dma_slave_base_address;
      } else {
        offset = 0;
      }
      discovery_ext->add_address(base + offset);
      discovery_ext->add_address(base + offset + this->dma_slave_size);
      if (this->mem_slave_subtract_base_address) {
        offset = this->mem_slave_base_address;
      } else {
        offset = 0;
      }
      discovery_ext->add_address(base + offset);
      discovery_ext->add_address(base + offset + this->mem_slave_size);
      if (this->code_and_data_subtract_base_address) {
        offset = this->code_and_data_base_address;
      } else {
        offset = 0;
      }
      discovery_ext->add_address(base + offset);
      discovery_ext->add_address(base + offset + this->code_and_data_size);
      if (this->console_subtract_base_address) {
        offset = this->console_base_address;
      } else {
        offset = 0;
      }
      discovery_ext->add_address(base + offset);
      discovery_ext->add_address(base + offset + this->console_size);
    }

     sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(2, trans.get_address());
     std::vector<long> slavePortIndexArray;
     esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
     if (secure_inst) {
       if (secure_inst->get_security_value(trans) ==
           esl::sc_sim::secure_payload::NON_SECURE)
         decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(2), 2, true);
       else
         decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(2), 2, true);
      } else
       decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(2), true);
     if (slavePortIndexArray.size() == 0 || 
         (write_broadcast && trans.is_write())) {
      dmiData.set_start_address(trans.get_address());
      dmiData.set_end_address(trans.get_address());
      return false;
    }
     
     long slavePortIndex = slavePortIndexArray[0];
    if (mb_unlikely(discovery_ext != 0)) {
      sc_dt::uint64 base = discovery_ext->get_base_address(trans);
      config::uint64 startAddress, endAddress; bool subtractBaseAddress;
      decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
      discovery_ext->set_current_range(base + startAddress, base + endAddress);
    }

    sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
    sc_dt::uint64 address = trans.get_address();
    trans.set_address(baseAddress);
    bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
    trans.set_address(address);

    // clip the range
    sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
    sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
    unsigned char* dmiPtr = dmiData.get_dmi_ptr();
    signed long long offset = address - virtualAddress;
    mb::tlm20::iss_core_ext *ext = 0;
    trans.get_extension(ext);
    clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset, ext);

    dmiData.set_start_address(dmiStartAddress);
    dmiData.set_end_address(dmiEndAddress);
    dmiData.set_dmi_ptr(dmiPtr);

    if (returnStatus) {
      if (secure_inst) {
        if (secure_inst->get_security_value(trans) ==
            esl::sc_sim::secure_payload::NON_SECURE &&
            decoder->getSecure(slavePortIndex, 2)) {
          trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
          returnStatus = false;
          dmiData.set_dmi_ptr(0);
          if(ext)
            ext->set_data_ptr(0);
          mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
          trans.get_extension(p_direct_call_ext);
          if (p_direct_call_ext)
            p_direct_call_ext->set_direct_call_if(0);
        }
      }
    }
    return returnStatus;
  }
}


void axi_bus_base1_pv::dma_master_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 3, false, t);
  
}

unsigned axi_bus_base1_pv::dma_master_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 3, true, t);

}

bool axi_bus_base1_pv::dma_master_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  if(m_fast_mode)
    return routePayload(trans, dmiData, 3);
  else {
    mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
      trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
    if (mb_unlikely(discovery_ext != 0)) {
      sc_dt::uint64 offset;
      sc_dt::uint64 base = discovery_ext->get_base_address(trans);
      if (this->dma_slave_subtract_base_address) {
        offset = this->dma_slave_base_address;
      } else {
        offset = 0;
      }
      discovery_ext->add_address(base + offset);
      discovery_ext->add_address(base + offset + this->dma_slave_size);
      if (this->mem_slave_subtract_base_address) {
        offset = this->mem_slave_base_address;
      } else {
        offset = 0;
      }
      discovery_ext->add_address(base + offset);
      discovery_ext->add_address(base + offset + this->mem_slave_size);
      if (this->code_and_data_subtract_base_address) {
        offset = this->code_and_data_base_address;
      } else {
        offset = 0;
      }
      discovery_ext->add_address(base + offset);
      discovery_ext->add_address(base + offset + this->code_and_data_size);
      if (this->console_subtract_base_address) {
        offset = this->console_base_address;
      } else {
        offset = 0;
      }
      discovery_ext->add_address(base + offset);
      discovery_ext->add_address(base + offset + this->console_size);
    }

     sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(3, trans.get_address());
     std::vector<long> slavePortIndexArray;
     esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
     if (secure_inst) {
       if (secure_inst->get_security_value(trans) ==
           esl::sc_sim::secure_payload::NON_SECURE)
         decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(3), 3, true);
       else
         decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(3), 3, true);
      } else
       decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(3), true);
     if (slavePortIndexArray.size() == 0 || 
         (write_broadcast && trans.is_write())) {
      dmiData.set_start_address(trans.get_address());
      dmiData.set_end_address(trans.get_address());
      return false;
    }
     
     long slavePortIndex = slavePortIndexArray[0];
    if (mb_unlikely(discovery_ext != 0)) {
      sc_dt::uint64 base = discovery_ext->get_base_address(trans);
      config::uint64 startAddress, endAddress; bool subtractBaseAddress;
      decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
      discovery_ext->set_current_range(base + startAddress, base + endAddress);
    }

    sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
    sc_dt::uint64 address = trans.get_address();
    trans.set_address(baseAddress);
    bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
    trans.set_address(address);

    // clip the range
    sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
    sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
    unsigned char* dmiPtr = dmiData.get_dmi_ptr();
    signed long long offset = address - virtualAddress;
    mb::tlm20::iss_core_ext *ext = 0;
    trans.get_extension(ext);
    clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset, ext);

    dmiData.set_start_address(dmiStartAddress);
    dmiData.set_end_address(dmiEndAddress);
    dmiData.set_dmi_ptr(dmiPtr);

    if (returnStatus) {
      if (secure_inst) {
        if (secure_inst->get_security_value(trans) ==
            esl::sc_sim::secure_payload::NON_SECURE &&
            decoder->getSecure(slavePortIndex, 3)) {
          trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
          returnStatus = false;
          dmiData.set_dmi_ptr(0);
          if(ext)
            ext->set_data_ptr(0);
          mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
          trans.get_extension(p_direct_call_ext);
          if (p_direct_call_ext)
            p_direct_call_ext->set_direct_call_if(0);
        }
      }
    }
    return returnStatus;
  }
}


void axi_bus_base1_pv::dbg_port_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, (unsigned) (-1), false, t);
}

unsigned axi_bus_base1_pv::dbg_port_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, (unsigned) (-1), true, t);
}

bool axi_bus_base1_pv::dbg_port_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {
  sc_dt::uint64 virtualAddress = trans.get_address();
  std::vector<long> slavePortIndexArray;
  decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, 32, name(), "dbg_port");
  if (slavePortIndexArray.size() == 0) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
  long slavePortIndex = slavePortIndexArray[0];
  

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  mb::tlm20::iss_core_ext *ext = 0;
  trans.get_extension(ext);
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset, ext);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  return returnStatus;
}

void axi_bus_base1_pv::clip_the_range(sc_dt::uint64 &dmiStartAddress,
                                            sc_dt::uint64 &dmiEndAddress,
                                            unsigned char* &dmiPtr,
                                            esl::sc_sim::user_model::SlaveRange* slaveRange,
                                            signed long long offset,
                                            mb::tlm20::iss_core_ext *ext) {

  bool isDefaultServer            = slaveRange->isDefaultServer();
  sc_dt::uint64 slaveStartAddress = isDefaultServer ? 0 : slaveRange->getSlaveStartAddress();
  sc_dt::uint64 slaveEndAddress   = isDefaultServer ? config::uint64_max : slaveRange->getSlaveEndAddress();
  bool subtractBaseAddress        = isDefaultServer ? false : slaveRange->getSubtractBaseAddress();
  sc_dt::uint64 delta = 0;

  if (subtractBaseAddress) {
    
    sc_dt::uint64 translatedEndAddress = slaveEndAddress - slaveStartAddress;
    if (dmiEndAddress > translatedEndAddress)
      dmiEndAddress = translatedEndAddress;
    
    dmiStartAddress += (slaveStartAddress);
    dmiEndAddress += (slaveStartAddress);
  } else {
    if (slaveStartAddress > dmiStartAddress) {
      if (slaveStartAddress < dmiEndAddress) {
        delta = slaveStartAddress - dmiStartAddress;
        dmiPtr += delta;
        dmiStartAddress = slaveStartAddress;
        if (ext && ext->get_data_ptr()) {
          ext->set_data_ptr(ext->get_data_ptr() + delta);
        }
      }
    }
    if (dmiEndAddress > slaveEndAddress) {
      if (slaveEndAddress > dmiStartAddress)
        dmiEndAddress = slaveEndAddress;
    }
  }
  // add the offset if from vmap parameter
  
  dmiStartAddress += (offset);
  dmiEndAddress += (offset);
}

void axi_bus_base1_pv::clip_the_range(sc_dt::uint64 address,
                                            sc_dt::uint64 &dmiStartAddress,
                                            sc_dt::uint64 &dmiEndAddress,
                                            unsigned char* &dmiPtr,
                                            long slavePortIndex,
                                            signed long long offset,
                                            mb::tlm20::iss_core_ext *ext) {
  sc_dt::uint64 slaveStartAddress = 0;
  sc_dt::uint64 slaveEndAddress = 0;
  bool subtractBaseAddress = true;
  decoder->getSlaveRangeByAddress(slavePortIndex, address, slaveStartAddress, slaveEndAddress, subtractBaseAddress);
  sc_dt::uint64 delta = 0;

  if (subtractBaseAddress) {
    
    sc_dt::uint64 translatedEndAddress = slaveEndAddress - slaveStartAddress;
    if (dmiEndAddress > translatedEndAddress)
      dmiEndAddress = translatedEndAddress;
    
    dmiStartAddress += (slaveStartAddress);
    dmiEndAddress += (slaveStartAddress);
  } else {
    if (slaveStartAddress > dmiStartAddress) {
      if (slaveStartAddress < dmiEndAddress) {
        delta = slaveStartAddress - dmiStartAddress;
        dmiPtr += delta;
        dmiStartAddress = slaveStartAddress;
        if (ext && ext->get_data_ptr()) {
          ext->set_data_ptr(ext->get_data_ptr() + delta);
        }
      }
    }
    if (dmiEndAddress > slaveEndAddress) {
      if (slaveEndAddress > dmiStartAddress)
        dmiEndAddress = slaveEndAddress;
    } else {
      if(slaveEndAddress==config::uint64_max) { //address is mapped to the default master port 
        std::stringstream str;
        str << "Attempt to try DMI access through default master port of base address: 0xFFFFFFFFFFFFFFFF. "
            << "Note that the effective DMI address range for this port will be "
            << std::hex << "0x" << dmiStartAddress <<":0x"<< (dmiEndAddress += (offset));
        mb::sysc::issue_warning(str.str().c_str(), this->name());
      }
    }
  }
  // add the offset if from vmap parameter
  
  dmiStartAddress += (offset);
  dmiEndAddress += (offset);
}

void axi_bus_base1_pv::invalidate_direct_mem_ptr_callback(unsigned master_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  if (m_in_loop)
    return;
  m_in_loop = true;
  config::uint64 startAddress;
  config::uint64 endAddress;
  bool substractBaseAddress;  
  decoder->getSlaveRange(master_index, startAddress, endAddress, substractBaseAddress);
  sc_dt::uint64 current_start_range = start_range;
  sc_dt::uint64 current_end_range = end_range;
  unsigned char* dmi_ptr = 0;
  clip_the_range(startAddress, current_start_range, current_end_range, dmi_ptr, master_index, 0, 0);
  sc_dt::uint64 original_address = 0;
original_address = decoder->getOriginalAddress(cpu_master_idx, current_start_range);
  invalidate_direct_mem_ptr(cpu_master_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(dma_master_idx, current_start_range);
  invalidate_direct_mem_ptr(dma_master_idx, original_address, original_address + current_end_range - current_start_range);
  m_in_loop = false;
}


void axi_bus_base1_pv::dma_slave_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(dma_slave_idx, start_range, end_range);
  }
void axi_bus_base1_pv::mem_slave_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(mem_slave_idx, start_range, end_range);
  }
void axi_bus_base1_pv::code_and_data_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(code_and_data_idx, start_range, end_range);
  }
void axi_bus_base1_pv::console_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(console_idx, start_range, end_range);
  }

void axi_bus_base1_pv::invalidate_direct_mem_ptr(unsigned target_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  switch(target_index) {
  case cpu_master_idx :
    cpu_master->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case dma_master_idx :
    dma_master->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  }
}

/**************************************************************/
/*                                                            */
/*               Copyright (c) Siemens 2021                   */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF SIEMENS       */
/*             CORPORATION OR ITS LICENSORS AND IS            */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

#include "axi_bus_model.h"

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;

void axi_bus_t_base::createDecoder(void* userRunningModel) {
  long* portLayers = 0;
  long* readAddressLayers = 0;
  long* writeAddressLayers = 0;
  long* readDataLayers = 0;
  long* writeDataLayers = 0;
  long** mastersVmap = 0;
  if (isMultiChannel && layers && *layers == 0)
    Papoulis_ParseLayersFile(userRunningModel,
                             "cpu_master: dma_slave, mem_slave, code_and_data, console; dma_master: dma_slave, mem_slave, code_and_data, console; ",
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);
    
  else
    Papoulis_ParseLayersFile(userRunningModel,
                             layers,
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);

  m_decoder = new esl::sc_sim::user_model::Decoder(4, mastersVmap, port_count, write_broadcast);
  if (!m_arbiter)
    m_arbiter = new esl::sc_sim::user_model::Arbiter(new esl::sc_sim::ArbiterScheme());
  m_arbiter->updateTables(port_count);
  m_arbiter->setDecoder(m_decoder);

  unsigned masterIndex = 0;
  for (unsigned u = 0; u < get_port_count(); u++)
    if (is_master(u)) {
      masterIndex = u;
      break;
    }

  m_decoder->insertPortName("dma_slave");
  m_decoder->insertPortName("mem_slave");
  m_decoder->insertPortName("cpu_master");
  m_decoder->insertPortName("dma_master");
  m_decoder->insertPortName("code_and_data");
  m_decoder->insertPortName("console");
  
  std::vector<esl::sc_sim::SystemCChannel*>* channels = getReadAndWriteChannels(masterIndex);
  if (channels->size() == 1) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_IGNORE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  } else if (channels->size() == 2) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_READ_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
    channel = (*channels)[1];
    protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_WRITE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  }

  if(isMultiChannel)
    m_arbiter->setMultiChannel();
  unsigned* pendings = new unsigned[port_count];
  pendings[dma_slave] = Papoulis_GetPending((void*)getUserRunningModel(), dma_slave);
  pendings[mem_slave] = Papoulis_GetPending((void*)getUserRunningModel(), mem_slave);
  pendings[cpu_master] = Papoulis_GetPending((void*)getUserRunningModel(), cpu_master);
  pendings[dma_master] = Papoulis_GetPending((void*)getUserRunningModel(), dma_master);
  pendings[code_and_data] = Papoulis_GetPending((void*)getUserRunningModel(), code_and_data);
  pendings[console] = Papoulis_GetPending((void*)getUserRunningModel(), console);
  m_arbiter->setPendings(pendings);
  sc_dt::uint64 base_address = 0;
  if (dma_slave_base_address == 0xffffffff && 
      sizeof(dma_slave_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = dma_slave_base_address;
  m_decoder->registerSlavePort(dma_slave,
                               base_address,
                               dma_slave_size,
                               dma_slave_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(dma_slave,
                                            "dma_slave",
                                            dma_slave_additional_ranges,
                                            dma_slave_subtract_base_address);
  m_decoder->setSecure(dma_slave, dma_slave_secure, config::uint32_max);

  if (mem_slave_base_address == 0xffffffff && 
      sizeof(mem_slave_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = mem_slave_base_address;
  m_decoder->registerSlavePort(mem_slave,
                               base_address,
                               mem_slave_size,
                               mem_slave_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(mem_slave,
                                            "mem_slave",
                                            mem_slave_additional_ranges,
                                            mem_slave_subtract_base_address);
  m_decoder->setSecure(mem_slave, mem_slave_secure, config::uint32_max);

  if (code_and_data_base_address == 0xffffffff && 
      sizeof(code_and_data_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = code_and_data_base_address;
  m_decoder->registerSlavePort(code_and_data,
                               base_address,
                               code_and_data_size,
                               code_and_data_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(code_and_data,
                                            "code_and_data",
                                            code_and_data_additional_ranges,
                                            code_and_data_subtract_base_address);
  m_decoder->setSecure(code_and_data, code_and_data_secure, config::uint32_max);

  if (console_base_address == 0xffffffff && 
      sizeof(console_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = console_base_address;
  m_decoder->registerSlavePort(console,
                               base_address,
                               console_size,
                               console_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(console,
                                            "console",
                                            console_additional_ranges,
                                            console_subtract_base_address);
  m_decoder->setSecure(console, console_secure, config::uint32_max);

  m_decoder->registerPortPriorityAndData(cpu_master, cpu_master_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(dma_slave, dma_slave_priority, (void*)0);
  m_decoder->parseVmapString(cpu_master, cpu_master_vmap, "cpu_master_vmap");
  m_decoder->registerPortPriorityAndData(dma_master, dma_master_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(mem_slave, mem_slave_priority, (void*)0);
  m_decoder->parseVmapString(dma_master, dma_master_vmap, "dma_master_vmap");
  m_decoder->registerPortPriorityAndData(dma_master, dma_master_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(code_and_data, code_and_data_priority, (void*)0);
  m_decoder->parseVmapString(dma_master, dma_master_vmap, "dma_master_vmap");
  m_decoder->registerPortPriorityAndData(dma_master, dma_master_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(console, console_priority, (void*)0);
  m_decoder->parseVmapString(dma_master, dma_master_vmap, "dma_master_vmap");
  m_decoder->checkConsistency(name());
  long portCount = 4 + 2;
  m_arbiter->generateLayerTable(portCount, portLayers, readAddressLayers, writeAddressLayers, readDataLayers, writeDataLayers);
}

void axi_bus_t_base::schedule_axi_READ
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long ARADDR, long* RDATA, long ARSIZE, long block_size, long ARBURST, long ARLEN, long ARLOCK) {
  scheduleGenericTransaction(portIndex,
                             0,
                             ARADDR,
                             (unsigned char*)RDATA,
                             transactionSize,
                             block_size,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}
void axi_bus_t_base::schedule_axi_WRITE
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long AWADDR, long* WDATA, long AWSIZE, long block_size, long AWBURST, long AWLEN, long AWLOCK) {
  scheduleGenericTransaction(portIndex,
                             1,
                             AWADDR,
                             (unsigned char*)WDATA,
                             transactionSize,
                             block_size,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

axi_bus_t_base::axi_bus_t_base(sc_module_name& module_name, long simulation,
                                           esl::sc_sim::user_model::Arbiter* arbiter) :
  papoulis::PapoulisBusBaseModel(module_name, arbiter, 1, 0),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(10, sc_core::SC_NS), "axi_bus"),
  SD_INITIALIZE_PARAMETER(axi_clock, clock, "axi_bus"),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER(port_enable, true, "axi_bus"),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true, "axi_bus"),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true, "axi_bus"),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING", "axi_bus"),
  SD_INITIALIZE_PARAMETER(layers, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER(slave_sets, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER(write_broadcast, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(dma_slave_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(dma_slave_base_address, 0x70000000, "axi_bus"),
  SD_INITIALIZE_PARAMETER(dma_slave_size, 0x10000, "axi_bus"),
  SD_INITIALIZE_PARAMETER(dma_slave_subtract_base_address, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER(dma_slave_secure, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(dma_slave_additional_ranges, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER(dma_slave_latency, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(mem_slave_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(mem_slave_base_address, 0x40000000, "axi_bus"),
  SD_INITIALIZE_PARAMETER(mem_slave_size, 0x100000, "axi_bus"),
  SD_INITIALIZE_PARAMETER(mem_slave_subtract_base_address, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER(mem_slave_secure, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(mem_slave_additional_ranges, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER(mem_slave_latency, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(cpu_master_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(cpu_master_vmap, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER(dma_master_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(dma_master_vmap, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER(code_and_data_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(code_and_data_base_address, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(code_and_data_size, 0x10000000, "axi_bus"),
  SD_INITIALIZE_PARAMETER(code_and_data_subtract_base_address, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER(code_and_data_secure, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(code_and_data_additional_ranges, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER(code_and_data_latency, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(console_priority, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(console_base_address, 0x60080000, "axi_bus"),
  SD_INITIALIZE_PARAMETER(console_size, 0x10000, "axi_bus"),
  SD_INITIALIZE_PARAMETER(console_subtract_base_address, 1, "axi_bus"),
  SD_INITIALIZE_PARAMETER(console_secure, 0, "axi_bus"),
  SD_INITIALIZE_PARAMETER(console_additional_ranges, "", "axi_bus"),
  SD_INITIALIZE_PARAMETER(console_latency, 0, "axi_bus"),
        m_simulation(simulation), m_current_request(0)
{
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  bool separate_read_channel = false;
  bool separate_write_channel = false;
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[dma_slave].port_name = "dma_slave";
  separate_read_channel = true;
  port_descriptions[dma_slave].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[dma_slave].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[dma_slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[dma_slave].is_master_port = 1;
  port_descriptions[dma_slave].is_signal_port = 0;
  port_descriptions[dma_slave].port_width = ((32 + 7) >> 3);
  port_descriptions[dma_slave].port_cast  = 0;
  port_descriptions[dma_slave].port_width_in_bits = 32;
  port_descriptions[dma_slave].protocol_name = "axi";
  port_descriptions[dma_slave].ipxactBusDef.vendor = "amba.com";
  port_descriptions[dma_slave].ipxactBusDef.library = "AMBA3";
  port_descriptions[dma_slave].ipxactBusDef.name = "AXI";
  port_descriptions[dma_slave].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[dma_slave].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[dma_slave].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[dma_slave].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[dma_slave].ipxactAbstrDef.version = "1.0";
  port_descriptions[dma_slave].port_must_bind = 1;
  port_descriptions[dma_slave].params_count = 8;
  port_descriptions[dma_slave].pending = 1;
  port_descriptions[dma_slave].read_data_queue_size = 0;
  port_descriptions[dma_slave].write_data_queue_size = 0;
  port_descriptions[dma_slave].clock = axi_clock;
  port_descriptions[dma_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[dma_slave].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[dma_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[dma_slave].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[dma_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[dma_slave].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[dma_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[dma_slave].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[mem_slave].port_name = "mem_slave";
  separate_read_channel = true;
  port_descriptions[mem_slave].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[mem_slave].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[mem_slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[mem_slave].is_master_port = 1;
  port_descriptions[mem_slave].is_signal_port = 0;
  port_descriptions[mem_slave].port_width = ((32 + 7) >> 3);
  port_descriptions[mem_slave].port_cast  = 0;
  port_descriptions[mem_slave].port_width_in_bits = 32;
  port_descriptions[mem_slave].protocol_name = "axi";
  port_descriptions[mem_slave].ipxactBusDef.vendor = "amba.com";
  port_descriptions[mem_slave].ipxactBusDef.library = "AMBA3";
  port_descriptions[mem_slave].ipxactBusDef.name = "AXI";
  port_descriptions[mem_slave].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[mem_slave].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[mem_slave].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[mem_slave].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[mem_slave].ipxactAbstrDef.version = "1.0";
  port_descriptions[mem_slave].port_must_bind = 1;
  port_descriptions[mem_slave].params_count = 8;
  port_descriptions[mem_slave].pending = 1;
  port_descriptions[mem_slave].read_data_queue_size = 0;
  port_descriptions[mem_slave].write_data_queue_size = 0;
  port_descriptions[mem_slave].clock = axi_clock;
  port_descriptions[mem_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[mem_slave].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[mem_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[mem_slave].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[mem_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[mem_slave].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[mem_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[mem_slave].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[cpu_master].port_name = "cpu_master";
  separate_read_channel = true;
  port_descriptions[cpu_master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[cpu_master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[cpu_master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[cpu_master].is_master_port = 0;
  port_descriptions[cpu_master].is_signal_port = 0;
  port_descriptions[cpu_master].port_width = ((32 + 7) >> 3);
  port_descriptions[cpu_master].port_cast  = 0;
  port_descriptions[cpu_master].port_width_in_bits = 32;
  port_descriptions[cpu_master].protocol_name = "axi";
  port_descriptions[cpu_master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[cpu_master].ipxactBusDef.library = "AMBA3";
  port_descriptions[cpu_master].ipxactBusDef.name = "AXI";
  port_descriptions[cpu_master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[cpu_master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[cpu_master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[cpu_master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[cpu_master].ipxactAbstrDef.version = "1.0";
  port_descriptions[cpu_master].port_must_bind = 1;
  port_descriptions[cpu_master].params_count = 8;
  port_descriptions[cpu_master].pending = 1;
  port_descriptions[cpu_master].read_data_queue_size = 0;
  port_descriptions[cpu_master].write_data_queue_size = 0;
  port_descriptions[cpu_master].clock = axi_clock;
  port_descriptions[cpu_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[cpu_master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[cpu_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[cpu_master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[cpu_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[cpu_master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[cpu_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[cpu_master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[dma_master].port_name = "dma_master";
  separate_read_channel = true;
  port_descriptions[dma_master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[dma_master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[dma_master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[dma_master].is_master_port = 0;
  port_descriptions[dma_master].is_signal_port = 0;
  port_descriptions[dma_master].port_width = ((32 + 7) >> 3);
  port_descriptions[dma_master].port_cast  = 0;
  port_descriptions[dma_master].port_width_in_bits = 32;
  port_descriptions[dma_master].protocol_name = "axi";
  port_descriptions[dma_master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[dma_master].ipxactBusDef.library = "AMBA3";
  port_descriptions[dma_master].ipxactBusDef.name = "AXI";
  port_descriptions[dma_master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[dma_master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[dma_master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[dma_master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[dma_master].ipxactAbstrDef.version = "1.0";
  port_descriptions[dma_master].port_must_bind = 1;
  port_descriptions[dma_master].params_count = 8;
  port_descriptions[dma_master].pending = 1;
  port_descriptions[dma_master].read_data_queue_size = 0;
  port_descriptions[dma_master].write_data_queue_size = 0;
  port_descriptions[dma_master].clock = axi_clock;
  port_descriptions[dma_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[dma_master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[dma_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[dma_master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[dma_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[dma_master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[dma_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[dma_master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[code_and_data].port_name = "code_and_data";
  separate_read_channel = true;
  port_descriptions[code_and_data].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[code_and_data].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[code_and_data].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[code_and_data].is_master_port = 1;
  port_descriptions[code_and_data].is_signal_port = 0;
  port_descriptions[code_and_data].port_width = ((32 + 7) >> 3);
  port_descriptions[code_and_data].port_cast  = 0;
  port_descriptions[code_and_data].port_width_in_bits = 32;
  port_descriptions[code_and_data].protocol_name = "axi";
  port_descriptions[code_and_data].ipxactBusDef.vendor = "amba.com";
  port_descriptions[code_and_data].ipxactBusDef.library = "AMBA3";
  port_descriptions[code_and_data].ipxactBusDef.name = "AXI";
  port_descriptions[code_and_data].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[code_and_data].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[code_and_data].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[code_and_data].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[code_and_data].ipxactAbstrDef.version = "1.0";
  port_descriptions[code_and_data].port_must_bind = 1;
  port_descriptions[code_and_data].params_count = 8;
  port_descriptions[code_and_data].pending = 1;
  port_descriptions[code_and_data].read_data_queue_size = 0;
  port_descriptions[code_and_data].write_data_queue_size = 0;
  port_descriptions[code_and_data].clock = axi_clock;
  port_descriptions[code_and_data].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[code_and_data].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[code_and_data].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[code_and_data].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[code_and_data].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[code_and_data].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[code_and_data].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[code_and_data].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[console].port_name = "console";
  separate_read_channel = true;
  port_descriptions[console].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[console].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[console].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[console].is_master_port = 1;
  port_descriptions[console].is_signal_port = 0;
  port_descriptions[console].port_width = ((32 + 7) >> 3);
  port_descriptions[console].port_cast  = 0;
  port_descriptions[console].port_width_in_bits = 32;
  port_descriptions[console].protocol_name = "axi";
  port_descriptions[console].ipxactBusDef.vendor = "amba.com";
  port_descriptions[console].ipxactBusDef.library = "AMBA3";
  port_descriptions[console].ipxactBusDef.name = "AXI";
  port_descriptions[console].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[console].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[console].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[console].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[console].ipxactAbstrDef.version = "1.0";
  port_descriptions[console].port_must_bind = 1;
  port_descriptions[console].params_count = 8;
  port_descriptions[console].pending = 1;
  port_descriptions[console].read_data_queue_size = 0;
  port_descriptions[console].write_data_queue_size = 0;
  port_descriptions[console].clock = axi_clock;
  port_descriptions[console].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[console].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[console].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[console].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[console].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[console].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[console].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[console].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);

  port_descriptions[dma_slave].default_read_transaction_name = "READ";
  port_descriptions[mem_slave].default_read_transaction_name = "READ";
  port_descriptions[cpu_master].default_read_transaction_name = "READ";
  port_descriptions[dma_master].default_read_transaction_name = "READ";
  port_descriptions[code_and_data].default_read_transaction_name = "READ";
  port_descriptions[console].default_read_transaction_name = "READ";

  port_descriptions[dma_slave].default_write_transaction_name = "WRITE";
  port_descriptions[mem_slave].default_write_transaction_name = "WRITE";
  port_descriptions[cpu_master].default_write_transaction_name = "WRITE";
  port_descriptions[dma_master].default_write_transaction_name = "WRITE";
  port_descriptions[code_and_data].default_write_transaction_name = "WRITE";
  port_descriptions[console].default_write_transaction_name = "WRITE";

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);
  
  esl::tlm_sim::UserRunningModel* model = Papoulis_CreateUserRunningModel(name(),
                                                                          0,
                                                                          this,
                                                                          simulation,
                                                                          true,
                                                                          false);
  setUserRunningModel(model, false);
  createDecoder(model);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("axi_clock", "sc_core::sc_time", sdGetParameterAsConstString("axi_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("port_enable", "bool", sdGetParameterAsConstString("port_enable"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("layers", "const char*", sdGetParameterAsConstString("layers"));
  registerParameter("slave_sets", "const char*", sdGetParameterAsConstString("slave_sets"));
  registerParameter("write_broadcast", "unsigned int", sdGetParameterAsConstString("write_broadcast"));
  registerParameter("dma_slave_priority", "unsigned int", sdGetParameterAsConstString("dma_slave_priority"));
  registerParameter("dma_slave_base_address", "unsigned long long", sdGetParameterAsConstString("dma_slave_base_address"));
  registerParameter("dma_slave_size", "unsigned long long", sdGetParameterAsConstString("dma_slave_size"));
  registerParameter("dma_slave_subtract_base_address", "unsigned int", sdGetParameterAsConstString("dma_slave_subtract_base_address"));
  registerParameter("dma_slave_secure", "unsigned int", sdGetParameterAsConstString("dma_slave_secure"));
  registerParameter("dma_slave_additional_ranges", "const char*", sdGetParameterAsConstString("dma_slave_additional_ranges"));
  registerParameter("dma_slave_latency", "unsigned int", sdGetParameterAsConstString("dma_slave_latency"));
  registerParameter("mem_slave_priority", "unsigned int", sdGetParameterAsConstString("mem_slave_priority"));
  registerParameter("mem_slave_base_address", "unsigned long long", sdGetParameterAsConstString("mem_slave_base_address"));
  registerParameter("mem_slave_size", "unsigned long long", sdGetParameterAsConstString("mem_slave_size"));
  registerParameter("mem_slave_subtract_base_address", "unsigned int", sdGetParameterAsConstString("mem_slave_subtract_base_address"));
  registerParameter("mem_slave_secure", "unsigned int", sdGetParameterAsConstString("mem_slave_secure"));
  registerParameter("mem_slave_additional_ranges", "const char*", sdGetParameterAsConstString("mem_slave_additional_ranges"));
  registerParameter("mem_slave_latency", "unsigned int", sdGetParameterAsConstString("mem_slave_latency"));
  registerParameter("cpu_master_priority", "unsigned int", sdGetParameterAsConstString("cpu_master_priority"));
  registerParameter("cpu_master_vmap", "const char*", sdGetParameterAsConstString("cpu_master_vmap"));
  registerParameter("dma_master_priority", "unsigned int", sdGetParameterAsConstString("dma_master_priority"));
  registerParameter("dma_master_vmap", "const char*", sdGetParameterAsConstString("dma_master_vmap"));
  registerParameter("code_and_data_priority", "unsigned int", sdGetParameterAsConstString("code_and_data_priority"));
  registerParameter("code_and_data_base_address", "unsigned long long", sdGetParameterAsConstString("code_and_data_base_address"));
  registerParameter("code_and_data_size", "unsigned long long", sdGetParameterAsConstString("code_and_data_size"));
  registerParameter("code_and_data_subtract_base_address", "unsigned int", sdGetParameterAsConstString("code_and_data_subtract_base_address"));
  registerParameter("code_and_data_secure", "unsigned int", sdGetParameterAsConstString("code_and_data_secure"));
  registerParameter("code_and_data_additional_ranges", "const char*", sdGetParameterAsConstString("code_and_data_additional_ranges"));
  registerParameter("code_and_data_latency", "unsigned int", sdGetParameterAsConstString("code_and_data_latency"));
  registerParameter("console_priority", "unsigned int", sdGetParameterAsConstString("console_priority"));
  registerParameter("console_base_address", "unsigned long long", sdGetParameterAsConstString("console_base_address"));
  registerParameter("console_size", "unsigned long long", sdGetParameterAsConstString("console_size"));
  registerParameter("console_subtract_base_address", "unsigned int", sdGetParameterAsConstString("console_subtract_base_address"));
  registerParameter("console_secure", "unsigned int", sdGetParameterAsConstString("console_secure"));
  registerParameter("console_additional_ranges", "const char*", sdGetParameterAsConstString("console_additional_ranges"));
  registerParameter("console_latency", "unsigned int", sdGetParameterAsConstString("console_latency"));
  

  delay_policy* delay_policy_handle = 0;

  delay_policy_handle = new delay_policy(model,
                                         "cpu_master",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "dma_master",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  unsigned pipeline_policy_index = 0;
  pipeline_policy* pipeline_policy_handle = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "cpu_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "dma_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(dma_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "cpu_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "mem_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(mem_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "cpu_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "code_and_data";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(code_and_data_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "cpu_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "console";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(console_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "dma_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "dma_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(dma_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "dma_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "mem_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(mem_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "dma_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "code_and_data";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(code_and_data_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "dma_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "console";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(console_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  set_user_pipeline_policies(user_pipeline_policy_count, user_pipeline_policy_descriptions);
  
  constant_global_power_policy* p = new constant_global_power_policy(model);
  
  
  
  set_global_power_policy(p);
}

void axi_bus_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;

  if (handle == m_pipeline_vector[0]) {
    handle->setLatency(dma_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[1]) {
    handle->setLatency(mem_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[2]) {
    handle->setLatency(code_and_data_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[3]) {
    handle->setLatency(console_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[4]) {
    handle->setLatency(dma_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[5]) {
    handle->setLatency(mem_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[6]) {
    handle->setLatency(code_and_data_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[7]) {
    handle->setLatency(console_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }

}

void axi_bus_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

  if (handle == m_delay_vector[0]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[1]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
}

void axi_bus_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}


void axi_bus_t_base::vista_trace(bool isStart, request_type* request, long portIndex, sc_dt::uint64 startTime) {
  
  sc_dt::uint64 local_params[8];
  for (unsigned u = 0; u < 8; u++)
    local_params[u] = 0;
  
  sc_dt::uint64 address = request->get_address();
  
  local_params[1] = address;
  
  local_params[4] = get_port_width(portIndex);
  sc_dt::uint64* parameters = local_params;
  long size = request->get_data_length();
  
  bool isWrite = request->is_write();
  m_current_request = request;
  if(isStart) {
    this->print_transaction(portIndex, isWrite, true, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->accept_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->accept_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    } else {
      if (is_master(portIndex)) {
        this->accept_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->accept_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    }
  } else {
    this->print_transaction(portIndex, isWrite, false, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->end_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->end_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    } else {
      if (is_master(portIndex)) {
        this->end_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->end_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    }
  }
  m_current_request = 0;
}

request_type* axi_bus_t_base::get_current_request() {
  return m_current_request;
}

unsigned axi_bus_t_base::get_layer(unsigned port_index) {
  if (is_slave(port_index))
    return m_arbiter->get_slave_layer(port_index);
  return m_arbiter->get_master_layer(port_index);
}

unsigned axi_bus_t_base::get_slave_port_index() {
  if (!m_current_request) {
    printf("ERROR: when calling get_slave_port_index in %s\n", name());
    return (unsigned)(-1);
  }
  return  m_arbiter->getMasterIndexByRequestId(m_current_request);
}

void axi_bus_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}



/**************************************************************/
/*                                                            */
/*               Copyright (c) Siemens 2021                   */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF SIEMENS       */
/*             CORPORATION OR ITS LICENSORS AND IS            */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for axi_bus.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 5.1.0
//* Generated on: Mar. 09, 2022 11:24:25 AM, (user: russk)
//*>

#include "axi_bus_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;



#include "axi_bus_pv.h"




// Constructor

axi_bus_pvt::axi_bus_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
    axi_bus_pvt_param_defaults(this->name()),
    dma_slave("dma_slave"),
    mem_slave("mem_slave"),
    code_and_data("code_and_data"),
    console("console"),
    cpu_master("cpu_master"),
    dma_master("dma_master"),
    dma_slave_entry("unvisible_dma_slave_entry"),
    mem_slave_entry("unvisible_mem_slave_entry"),
    code_and_data_entry("unvisible_code_and_data_entry"),
    console_entry("unvisible_console_entry"),
    cpu_master_entry("unvisible_cpu_master_entry"),
    dma_master_entry("unvisible_dma_master_entry")
  

  ,m_dma_slave_nb_connector(*this)
  ,m_mem_slave_nb_connector(*this)
  ,m_code_and_data_nb_connector(*this)
  ,m_console_nb_connector(*this),
    m_cpu_master_nb_connector(*this),
    m_dma_master_nb_connector(*this)
  
    

{
  // dma_slave - not a vector port
  // mem_slave - not a vector port
  // code_and_data - not a vector port
  // console - not a vector port
  // cpu_master - not a vector port
  // dma_master - not a vector port



  m_axi_bus_t = axi_bus_t_base::create_t("T", 1);
  m_axi_bus_pv = new axi_bus_pv("PV");
  bind();
}  


axi_bus_pvt::axi_bus_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time axi_clock_init, double nominal_voltage_init, bool port_enable_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, const char* layers_init, const char* slave_sets_init, unsigned int write_broadcast_init, unsigned int dma_slave_priority_init, unsigned long long dma_slave_base_address_init, unsigned long long dma_slave_size_init, unsigned int dma_slave_subtract_base_address_init, unsigned int dma_slave_secure_init, const char* dma_slave_additional_ranges_init, unsigned int dma_slave_latency_init, unsigned int mem_slave_priority_init, unsigned long long mem_slave_base_address_init, unsigned long long mem_slave_size_init, unsigned int mem_slave_subtract_base_address_init, unsigned int mem_slave_secure_init, const char* mem_slave_additional_ranges_init, unsigned int mem_slave_latency_init, unsigned int cpu_master_priority_init, const char* cpu_master_vmap_init, unsigned int dma_master_priority_init, const char* dma_master_vmap_init, unsigned int code_and_data_priority_init, unsigned long long code_and_data_base_address_init, unsigned long long code_and_data_size_init, unsigned int code_and_data_subtract_base_address_init, unsigned int code_and_data_secure_init, const char* code_and_data_additional_ranges_init, unsigned int code_and_data_latency_init, unsigned int console_priority_init, unsigned long long console_base_address_init, unsigned long long console_size_init, unsigned int console_subtract_base_address_init, unsigned int console_secure_init, const char* console_additional_ranges_init, unsigned int console_latency_init)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  axi_bus_pvt_param_defaults(this->name(), clock_init, axi_clock_init, nominal_voltage_init, port_enable_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, layers_init, slave_sets_init, write_broadcast_init, dma_slave_priority_init, dma_slave_base_address_init, dma_slave_size_init, dma_slave_subtract_base_address_init, dma_slave_secure_init, dma_slave_additional_ranges_init, dma_slave_latency_init, mem_slave_priority_init, mem_slave_base_address_init, mem_slave_size_init, mem_slave_subtract_base_address_init, mem_slave_secure_init, mem_slave_additional_ranges_init, mem_slave_latency_init, cpu_master_priority_init, cpu_master_vmap_init, dma_master_priority_init, dma_master_vmap_init, code_and_data_priority_init, code_and_data_base_address_init, code_and_data_size_init, code_and_data_subtract_base_address_init, code_and_data_secure_init, code_and_data_additional_ranges_init, code_and_data_latency_init, console_priority_init, console_base_address_init, console_size_init, console_subtract_base_address_init, console_secure_init, console_additional_ranges_init, console_latency_init),
    dma_slave("dma_slave"),
    mem_slave("mem_slave"),
    code_and_data("code_and_data"),
    console("console"),
    cpu_master("cpu_master"),
    dma_master("dma_master"),
    dma_slave_entry("unvisible_dma_slave_entry"),
    mem_slave_entry("unvisible_mem_slave_entry"),
    code_and_data_entry("unvisible_code_and_data_entry"),
    console_entry("unvisible_console_entry"),
    cpu_master_entry("unvisible_cpu_master_entry"),
    dma_master_entry("unvisible_dma_master_entry")
    

    ,m_dma_slave_nb_connector(*this)
    ,m_mem_slave_nb_connector(*this)
    ,m_code_and_data_nb_connector(*this)
    ,m_console_nb_connector(*this),
    m_cpu_master_nb_connector(*this),
    m_dma_master_nb_connector(*this)
    
    
{

  // dma_slave - not a vector port
  // mem_slave - not a vector port
  // code_and_data - not a vector port
  // console - not a vector port
  // cpu_master - not a vector port
  // dma_master - not a vector port
  


  m_axi_bus_t = axi_bus_t_base::create_t("T", 1);
  m_axi_bus_pv = new axi_bus_pv("PV");
  bind();
} 


axi_bus_pvt::axi_bus_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  axi_bus_pvt_param_defaults(this->name(), change_parameters),
    dma_slave("dma_slave"),
    mem_slave("mem_slave"),
    code_and_data("code_and_data"),
    console("console"),
    cpu_master("cpu_master"),
    dma_master("dma_master"),
    dma_slave_entry("unvisible_dma_slave_entry"),
    mem_slave_entry("unvisible_mem_slave_entry"),
    code_and_data_entry("unvisible_code_and_data_entry"),
    console_entry("unvisible_console_entry"),
    cpu_master_entry("unvisible_cpu_master_entry"),
    dma_master_entry("unvisible_dma_master_entry")
    

    ,m_dma_slave_nb_connector(*this)
    ,m_mem_slave_nb_connector(*this)
    ,m_code_and_data_nb_connector(*this)
    ,m_console_nb_connector(*this),
    m_cpu_master_nb_connector(*this),
    m_dma_master_nb_connector(*this)
    
{

  // dma_slave - not a vector port
  // mem_slave - not a vector port
  // code_and_data - not a vector port
  // console - not a vector port
  // cpu_master - not a vector port
  // dma_master - not a vector port
  


  m_axi_bus_t = axi_bus_t_base::create_t("T", 1);
  m_axi_bus_pv = new axi_bus_pv("PV");
  bind();
} 


axi_bus_pvt::~axi_bus_pvt() {
  remove_pending_scenes();
  
  delete m_axi_bus_t;
  
  delete m_axi_bus_pv;
}





void axi_bus_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->dma_slave.bind(dma_slave_entry);
  getPV()->mem_slave.bind(mem_slave_entry);
  getPV()->code_and_data.bind(code_and_data_entry);
  getPV()->console.bind(console_entry);
  cpu_master_entry.bind(getPV()->cpu_master); 
  dma_master_entry.bind(getPV()->dma_master);   

  /* set callbacks on external and entry ports */ 

  cpu_master.b_transport_cb.set(&cpu_master_entry, &cpu_master_entry_type::b_transport);
  cpu_master.transport_dbg_cb.set(&cpu_master_entry, &cpu_master_entry_type::transport_dbg);
  cpu_master.get_direct_mem_ptr_cb.set(&cpu_master_entry, &cpu_master_entry_type::get_direct_mem_ptr);
  
  dma_master.b_transport_cb.set(&dma_master_entry, &dma_master_entry_type::b_transport);
  dma_master.transport_dbg_cb.set(&dma_master_entry, &dma_master_entry_type::transport_dbg);
  dma_master.get_direct_mem_ptr_cb.set(&dma_master_entry, &dma_master_entry_type::get_direct_mem_ptr);
  
  dma_slave_entry.b_transport_cb.set(this, &self_type::b_transport_outside_dma_slave);
  dma_slave_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_dma_slave);
  dma_slave_entry.get_direct_mem_ptr_cb.set(&dma_slave, &dma_slave_type::get_direct_mem_ptr);
  
  mem_slave_entry.b_transport_cb.set(this, &self_type::b_transport_outside_mem_slave);
  mem_slave_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_mem_slave);
  mem_slave_entry.get_direct_mem_ptr_cb.set(&mem_slave, &mem_slave_type::get_direct_mem_ptr);
  
  code_and_data_entry.b_transport_cb.set(this, &self_type::b_transport_outside_code_and_data);
  code_and_data_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_code_and_data);
  code_and_data_entry.get_direct_mem_ptr_cb.set(&code_and_data, &code_and_data_type::get_direct_mem_ptr);
  
  console_entry.b_transport_cb.set(this, &self_type::b_transport_outside_console);
  console_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_console);
  console_entry.get_direct_mem_ptr_cb.set(&console, &console_type::get_direct_mem_ptr);
  
  
  /* connect t non blocking callbacks */

  dma_slave.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_dma_slave);
  getT()->set_port_cb(0, &m_dma_slave_nb_connector);
  
  mem_slave.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_mem_slave);
  getT()->set_port_cb(1, &m_mem_slave_nb_connector);
  
  code_and_data.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_code_and_data);
  getT()->set_port_cb(4, &m_code_and_data_nb_connector);
  
  console.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_console);
  getT()->set_port_cb(5, &m_console_nb_connector);
  
  cpu_master.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_cpu_master);
  getT()->set_port_cb(2, &m_cpu_master_nb_connector);
  
  dma_master.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_dma_master);
  getT()->set_port_cb(3, &m_dma_master_nb_connector);
  
  cpu_master_entry.invalidate_direct_mem_ptr_cb.set(&cpu_master, &cpu_master_type::invalidate_direct_mem_ptr);

  dma_master_entry.invalidate_direct_mem_ptr_cb.set(&dma_master, &dma_master_type::invalidate_direct_mem_ptr);

  dma_slave.invalidate_direct_mem_ptr_cb.set(&dma_slave_entry, &dma_slave_entry_type::invalidate_direct_mem_ptr);
  
  mem_slave.invalidate_direct_mem_ptr_cb.set(&mem_slave_entry, &mem_slave_entry_type::invalidate_direct_mem_ptr);
  
  code_and_data.invalidate_direct_mem_ptr_cb.set(&code_and_data_entry, &code_and_data_entry_type::invalidate_direct_mem_ptr);
  
  console.invalidate_direct_mem_ptr_cb.set(&console_entry, &console_entry_type::invalidate_direct_mem_ptr);
  
  /* check mb_event policies */
  m_axi_bus_t->check_mb_events();
  
}




void axi_bus_pvt::b_transport_outside_dma_slave(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  dma_slave.b_transport(p, t); 
} 


unsigned int axi_bus_pvt::transport_dbg_outside_dma_slave(tlm::tlm_generic_payload& p)
{
  

  return dma_slave.transport_dbg(p); 
}


void axi_bus_pvt::b_transport_outside_mem_slave(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  mem_slave.b_transport(p, t); 
} 


unsigned int axi_bus_pvt::transport_dbg_outside_mem_slave(tlm::tlm_generic_payload& p)
{
  

  return mem_slave.transport_dbg(p); 
}


void axi_bus_pvt::b_transport_outside_code_and_data(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  code_and_data.b_transport(p, t); 
} 


unsigned int axi_bus_pvt::transport_dbg_outside_code_and_data(tlm::tlm_generic_payload& p)
{
  

  return code_and_data.transport_dbg(p); 
}


void axi_bus_pvt::b_transport_outside_console(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  console.b_transport(p, t); 
} 


unsigned int axi_bus_pvt::transport_dbg_outside_console(tlm::tlm_generic_payload& p)
{
  

  return console.transport_dbg(p); 
}



