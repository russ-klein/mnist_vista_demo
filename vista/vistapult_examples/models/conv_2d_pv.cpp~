
/**************************************************************/
/*                                                            */
/*               Copyright (c) Siemens 2021                   */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF SIEMENS       */
/*             CORPORATION OR ITS LICENSORS AND IS            */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for conv_2d.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 5.1.0
//* Generated on: May. 24, 2022 12:54:06 PM, (user: russk)
//*>



#include "conv_2d_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor

conv_2d_pv::conv_2d_pv(sc_module_name module_name)
  : conv_2d_pv_base(module_name) {
}   

/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a 
// write event on one of the registers as defined in the Model Builder form.
// These functions are called before the write callbacks on the port.
///////////////////////////////////////////////////////////////////////////////// 

// Write callback for go register.
// The newValue has been already assigned to the go register.

void conv_2d_pv::cb_write_go(unsigned int newValue) {
  
}
    

// Read callback for slave port.
// Returns true when successful.

bool conv_2d_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

// Write callback for slave port.
// Returns true when successful.

bool conv_2d_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
} 





unsigned conv_2d_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned conv_2d_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool conv_2d_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

void conv_2d_pv::cb_transport_dbg_go(tlm::tlm_generic_payload& trans) {

  if (go_ready) {
    go_ready = 0;
    done = 0;

    conv_2d_vista();

    go_ready = 1;
    done = 1;
  }
}


conv_2d_pv::hw_cat_type conv_2d_pv::get_cat_value(int memory, unsigned int address)
{
  unsigned int buffer[10];
  hw_cat_type r;

  master_read(address, buffer, 1);
  r.set_slc(0, (ac_int<32,false>) buffer[0]);
  return r;
}

void conv_2d_pv::set_cat_value(int memory, unsigned int address, hw_cat_type data)
{
  unsigned int buffer[10];
  unsigned int d;

  buffer[0] = data.slc<32>(0);
  master_write(address, buffer, 1);
}

int conv_2d_pv::in_bounds(
              int r,
              int c,
              int height,
              int width)
{
    if (r < 0)        return 0;
    if (r >= height)  return 0;
    if (c < 0)        return 0;
    if (c >= width)   return 0;
    return 1;
}


int conv_2d_pv::offset(int row, int col, int image, int height, int width, int images)
{
    int start_of_array = image * height * width;
    int pixel_offset = (row * width) + col;

    return start_of_array + pixel_offset;
}


#define OFFSET(ROW, COL, IMAGE) offset(ROW, COL, IMAGE, height, width, num_input_images)

int conv_2d_pv::weight_offset(int row, int col, int input_image, int output_image, int height, int width, int num_input_images, int num_output_images)
{
    return output_image * height * width * num_input_images + input_image * height * width + row * width + col;
}


#define WEIGHT_OFFSET(ROW, COL, IN_IMAGE, OUT_IMAGE) weight_offset(ROW, COL, IN_IMAGE, OUT_IMAGE, filter_height, filter_width, num_input_images, num_output_images)



unsigned int conv_2d_pv::vista_read_bus(unsigned int address)
{
  unsigned int buffer[1];
  master_read(address, buffer, 1);
  return(buffer[0]);
}

void conv_2d_pv::vista_write_bus(unsigned int address, unsigned int data)
{
  unsigned int buffer[1];

  buffer[0] = data;
  master_write(address, buffer, 1);
}

// in order to minimize merging conflicts, we recommend to add your functions after this commen

void conv_2d_pv::conv_2d_vista()
{
    int  o, i, fr, fc, r, c, rr, cc, r1, c1;
    hw_cat_type sum;
    hw_cat_type max;
    hw_cat_type n;
    hw_cat_type image_value;
    hw_cat_type weight_value;
    hw_cat_type bias_value;
    int image_index;
    int weight_index;
    int output_index;
    int input_index;

    const int chatty = 0;

    int memory = 0;

    for (o=0; o<num_output_images; o++) {
        for (i=0; i<num_input_images; i++) {
            for (r=0; r<height; r++) {
                for (c=0; c<width; c++) {
                    sum = 0.0;
                    for (fr=0; fr<filter_height; fr++) {
                        for (fc=0; fc<filter_width; fc++) {

                            rr = r + fr - (filter_height -1)/2;
                            cc = c + fc - (filter_width -1)/2;

                            if (in_bounds(rr, cc, height, width)) {

                                image_index = OFFSET(rr, cc, i);
                                weight_index = WEIGHT_OFFSET(fr, fc, i, o);
                               
                                image_value = get_cat_value(memory, image + image_index);
                                weight_value = get_cat_value(memory, weights + weight_index);

                                if (chatty) printf("SW image_index: %d weight_index: %d image_value[%d][%d]: %5.3f weight_value: %5.3f = %5.3f \n",
                                                   image_index, weight_index, r+fr, c+fc, image_value.to_double(),
                                                   weight_value.to_double(), image_value.to_double() * weight_value.to_double());

                                sum += image_value * weight_value;
                            }
                        }
                    }
                    output_index = OFFSET(r, c, o);
                    if (i==0) n = sum; else n = sum + get_cat_value(memory, output_image + output_index);
                    set_cat_value(memory, output_image + output_index, n);
                    if (chatty) printf("output[%d] = %5.3f \n", output_index, n.to_double());
                }
            }
        }
        if (bias) {
            for (r=0; r<height; r++) {
                for (c=0; c<width; c++) {
                    output_index = OFFSET(r, c, o);
                    image_value = get_cat_value(memory, output_image + output_index);
                    bias_value = get_cat_value(memory, biases + o);
                    set_cat_value(memory, output_image + output_index, image_value + bias_value);
                }
            }
        }
        if (relu) {
            for (r=0; r<height; r++) {
                for (c=0; c<width; c++) {
                    output_index = OFFSET(r, c, o);
                    n = get_cat_value(memory, output_image + output_index);
                    if (n<0) set_cat_value(memory, output_image + output_index, 0.0);
                }
            }
        }
    }
}
